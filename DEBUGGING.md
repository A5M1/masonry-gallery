# Crash Dump Analysis Guide

This guide explains how to analyze crash dump files generated by the Masonry Gallery application when it encounters an unhandled exception.

## Overview

When the application crashes, it automatically generates:
1. A detailed crash log to stderr/log file
2. A minidump file in the `dmp/` directory with timestamp (e.g., `crashdump_20251118_143025.dmp`)

## Crash Information Captured

The exception handler captures comprehensive debugging information:

- **Exception Details**: Code and human-readable description (e.g., 0xC000041D - Fatal App Exit)
- **Register State**: CPU registers at the time of crash (RAX, RBX, RIP, etc.)
- **Stack Trace**: Call stack with symbols and line numbers (when available)
- **Memory Information**: Working set, page faults, memory usage
- **Loaded Modules**: All DLLs/modules with base addresses and sizes
- **Recent Commands**: Most recent operations before crash
- **Thread Information**: Process ID, Thread ID

## Analyzing Crash Dumps on Windows

### Prerequisites

1. **Windows Debugger (WinDbg)**
   - Download from: https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/
   - Or install Windows SDK which includes debugging tools

2. **Symbol Files**
   - For best results, compile with debug symbols: `make debug`
   - Set symbol path in WinDbg: `.sympath srv*c:\symbols*https://msdl.microsoft.com/download/symbols`

### Opening a Crash Dump

```
windbg -z dmp\crashdump_YYYYMMDD_HHMMSS.dmp
```

### Common WinDbg Commands

#### Analyze the Crash
```
!analyze -v
```
This performs automatic analysis and shows:
- Exception type and code
- Faulting instruction
- Stack trace
- Probable cause

#### View Exception Context
```
.ecxr
```
Sets the context to the exception record, allowing you to examine the exact state at crash time.

#### Display Stack Trace
```
k    # Basic stack trace
kb   # Stack trace with first 3 parameters
kv   # Verbose stack trace with FPO info
```

#### Examine Registers
```
r    # Display all registers
r rax, rbx, rcx    # Display specific registers
```

#### View Memory at Address
```
db <address>    # Display bytes
dw <address>    # Display words
dd <address>    # Display dwords
dq <address>    # Display qwords
du <address>    # Display Unicode string
da <address>    # Display ASCII string
```

#### Disassemble Code
```
u <address>    # Unassemble at address
ub <address>   # Unassemble before address
uf <function>  # Unassemble entire function
```

#### List Loaded Modules
```
lm    # List all modules
lmv   # Verbose module list
lmvm <module>    # Detailed info for specific module
```

#### Search for Symbols
```
x <module>!<symbol>    # Search for symbol
x *!main               # Find all 'main' symbols
```

### Example Debugging Session

Here's how to debug the exception code 0xC000041D mentioned in the problem statement:

```
# 1. Load the dump
windbg -z dmp\crashdump_20251118_143025.dmp

# 2. Analyze automatically - this often identifies the root cause
!analyze -v

# 3. Set exception context to see the exact state at crash
.ecxr

# 4. View stack trace with all details
kv

# 5. Check the exception code - 0xC000041D typically means "Fatal App Exit"
#    This usually indicates an unhandled exception was caught by a previous handler
#    Look for the original exception by examining the call stack

# 6. Examine the instruction pointer
u @rip

# 7. Check register values (they often contain useful clues)
r

# 8. If there's a faulting address, examine memory at that location
dd <address>

# 9. Look for symbols near the crash point
ln @rip

# 10. Check for nested exceptions or previous handlers
!exchain
```

### Understanding Exception Code 0xC000041D

The exception code **0xC000041D** (Fatal App Exit / Unhandled Exception) is special because it indicates:

1. **Secondary Exception**: An exception occurred while handling another exception
2. **Unhandled Exception Chain**: A previous exception handler caught an exception but couldn't properly handle it
3. **Possible Causes**:
   - Exception in exception handler code itself
   - Stack corruption during exception handling
   - Missing or incorrect exception handler setup
   - Termination after failed exception handling

**Debugging Strategy for 0xC000041D:**
1. Look at the stack trace to identify what exception handler was active
2. Check for any previous exceptions in the logs before the 0xC000041D
3. Examine the recent commands log - often shows what operation triggered the original issue
4. Review the register state and memory to understand the original fault
5. Use `!analyze -v` output to find the "FAULTING_IP" and "EXCEPTION_RECORD" details

# 5. Examine the faulting instruction
u @rip

# 6. Check register values
r

# 7. If it's an access violation, check the address
dd <faulting_address>

# 8. Find symbols near the crash
ln @rip
```

## Common Exception Codes

| Code | Name | Description |
|------|------|-------------|
| 0xC0000005 | EXCEPTION_ACCESS_VIOLATION | Invalid memory access (read/write to bad address) |
| 0xC000001D | EXCEPTION_ILLEGAL_INSTRUCTION | Attempted to execute invalid instruction |
| 0xC0000094 | EXCEPTION_INT_DIVIDE_BY_ZERO | Integer division by zero |
| 0xC000008C | EXCEPTION_ARRAY_BOUNDS_EXCEEDED | Array index out of bounds |
| 0xC00000FD | EXCEPTION_STACK_OVERFLOW | Stack overflow (too much recursion or large stack variables) |
| 0xC000041D | Fatal App Exit | Unhandled exception from previous exception handler |
| 0xE06D7363 | C++ Exception | Unhandled C++ exception |

## Debugging with Symbols

For optimal debugging, compile with debug information:

```bash
# Windows x64 debug build
make debug

# Windows ARM64 debug build  
make debug-arm
```

Debug builds include:
- Full symbol information
- Source file and line numbers
- Unoptimized code (easier to follow)
- Debug assertions enabled

## Analyzing Stack Traces

The application attempts to resolve symbols automatically using DbgHelp. Stack traces show:

```
[00] 0x00007FF6AB123456: function_name+0x42 (file.c:123)
[01] 0x00007FF6AB123789: caller_function+0x15 (file.c:456)
```

Without symbols, you'll only see addresses:
```
[00] 0x00007FF6AB123456
[01] 0x00007FF6AB123789
```

Use the module base addresses from the log to calculate offsets for manual analysis.

## Tips for Debugging

1. **Check Recent Commands**: The crash log shows recent operations - often the crash relates to the last command
2. **Examine Register State**: For access violations, registers often contain the bad pointer
3. **Look for Patterns**: If crashes occur at the same address repeatedly, it's likely a specific code path
4. **Check Memory Usage**: High memory usage before crash may indicate memory leak or corruption
5. **Compare Module Versions**: Ensure all DLLs are expected versions
6. **Review Thread State**: Multi-threading issues may show in thread information

## Getting Help

When reporting crashes, include:
1. The full crash log from stderr/log file
2. The minidump file (compress if large)
3. Steps to reproduce (if known)
4. System information (Windows version, architecture)
5. Application version and build type (release/debug)

## Advanced: Post-Mortem Debugging

For recurring crashes, consider:
1. Enable Windows Error Reporting (WER) for automatic crash collection
2. Set up a symbol server for easier symbol management
3. Use Time Travel Debugging (TTD) for complex issues
4. Implement application telemetry to understand crash context

## References

- [WinDbg Documentation](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/)
- [Debugging Tools for Windows](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools)
- [Common WinDbg Commands](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/commands)
- [DbgHelp API](https://docs.microsoft.com/en-us/windows/win32/debug/dbghelp-functions)
