#include "api_handlers.h"
#include "directory.h"
#include "http.h"
#include "utils.h"
#include "logging.h"
#include "config.h"

const char* IMAGE_EXTS[]={ ".jpg", ".jpeg", ".png", ".gif", ".webp", NULL };
const char* VIDEO_EXTS[]={ ".mp4", ".webm", ".ogg", NULL };

bool has_nogallery(const char* dir) {
	char p[PATH_MAX];
	path_join(p, dir, ".nogallery");
	return is_file(p);
}

bool has_media_rec(const char* dir) {
	if(has_nogallery(dir)) return false;

	diriter it;
	if(!dir_open(&it, dir)) {
		return false;
	}

	const char* name;
	bool found=false;

	while((name=dir_next(&it))&&!found) {
		if(!strcmp(name, ".")||!strcmp(name, "..")) continue;

		char full[PATH_MAX];
		path_join(full, dir, name);

		if(is_file(full)) {
			found=has_ext(name, IMAGE_EXTS)||has_ext(name, VIDEO_EXTS);
			if(found) break;
		}
	}
	if(!found) {
		dir_close(&it);
		if(!dir_open(&it, dir)) {
			return false;
		}

		while((name=dir_next(&it))&&!found) {
			if(!strcmp(name, ".")||!strcmp(name, "..")) continue;

			char full[PATH_MAX];
			path_join(full, dir, name);

			if(is_dir(full)&&!has_nogallery(full)) {
				found=has_media_rec(full);
				if(found) break;
			}
		}
	}

	dir_close(&it);
	return found;
}

static void build_folder_tree(const char* dir, const char* root, char** buf, size_t* cap, size_t* len) {
	if(!is_dir(dir)||has_nogallery(dir)||!has_media_rec(dir)) {
		sb_append(buf, cap, len, "null");
		return;
	}

	const char* base=strrchr(dir, DIR_SEP);
	base=base ? base+1 : dir;
	sb_append(buf, cap, len, "{\"name\":\"");
	sb_append_esc(buf, cap, len, base);
	sb_append(buf, cap, len, "\",");

	char rroot[PATH_MAX], rdir[PATH_MAX];
	real_path(root, rroot);
	real_path(dir, rdir);
	const char* r=rdir;
	size_t rl=strlen(rroot);
	if(safe_under(rroot, rdir)) {
		r=rdir+rl+((rdir[rl]==DIR_SEP) ? 1 : 0);
	}

	char relurl[PATH_MAX];
	size_t j=0;
	for(size_t i=0; r[i]&&j<PATH_MAX-1; ++i) {
		char ch=r[i];
		if(ch=='\\') ch='/';
		relurl[j++]=ch;
	}
	relurl[j]='\0';

	sb_append(buf, cap, len, "\"path\":\"");
	sb_append_esc(buf, cap, len, relurl);
	sb_append(buf, cap, len, "\",\"children\":[");

	char** names=NULL;
	size_t n=0, alloc=0;
	diriter it;

	if(dir_open(&it, dir)) {
		const char* name;
		while((name=dir_next(&it))) {
			if(!strcmp(name, ".")||!strcmp(name, "..")) continue;

			char full[PATH_MAX];
			path_join(full, dir, name);

			if(is_dir(full)&&!has_nogallery(full)&&has_media_rec(full)) {
				if(n==alloc) {
					alloc=alloc ? alloc*2 : 16;
					names=realloc(names, alloc*sizeof(char*));
				}
				names[n++]=strdup(name);
			}
		}
		dir_close(&it);
	}

	qsort(names, n, sizeof(char*), ci_cmp);
	for(size_t i=0; i<n; i++) {
		if(i) sb_append(buf, cap, len, ",");
		char child[PATH_MAX];
		path_join(child, dir, names[i]);
		build_folder_tree(child, root, buf, cap, len);
		SAFE_FREE(names[i]);
	}
	SAFE_FREE(names);

	sb_append(buf, cap, len, "]}");
}


void handle_api_tree(int c, bool keep_alive) {
	size_t count;
	char** folders = get_gallery_folders(&count);

	size_t cap = 4096, len = 0;
	char* out = malloc(cap);
	out[0] = '\0';

	if (count == 1) {
		build_folder_tree(folders[0], folders[0], &out, &cap, &len);
	} else {
		sb_append(&out, &cap, &len, "{\"name\":\"root\",\"path\":\"\",\"children\":[");
		for (size_t i = 0; i < count; ++i) {
			if (i) sb_append(&out, &cap, &len, ",");
			build_folder_tree(folders[i], folders[i], &out, &cap, &len);
		}
		sb_append(&out, &cap, &len, "]}");
	}

	send_header(c, 200, "OK", "application/json; charset=utf-8", (long)len, NULL, 0, keep_alive);
	send(c, out, (int)len, 0);
	SAFE_FREE(out);
}


void handle_api_folders(int c, char* qs, bool keep_alive) {
	char dirparam[PATH_MAX]={ 0 };
	if(qs) {
		char* v=query_get(qs, "dir");
		if(v) {
			size_t max_len=sizeof(dirparam)-1;
			strncpy(dirparam, v, max_len);
			dirparam[max_len]='\0';
			SAFE_FREE(v);
		}
	}
	char target[PATH_MAX];
	size_t base_len=strlen(BASE_DIR);
	size_t dir_len=strlen(dirparam);
	if(base_len+1+dir_len>=sizeof(target)) {
		dirparam[sizeof(target)-base_len-2]='\0';
		dir_len=strlen(dirparam); 
	}
	snprintf(target, sizeof(target), "%.*s/%.*s",
		(int)base_len, BASE_DIR,
		(int)dir_len, dirparam);
	normalize_path(target);
	char base_real[PATH_MAX], target_real[PATH_MAX];
	if(!real_path(BASE_DIR, base_real)||!real_path(target, target_real)||
		!safe_under(base_real, target_real)||!is_dir(target_real)) {
		const char* msg="{\"error\":\"Invalid directory\"}";
		send_header(c, 400, "Bad Request", "application/json; charset=utf-8", (long)strlen(msg), NULL, 0, keep_alive);
		send(c, msg, (int)strlen(msg), 0);
		return;
	}
	if(!is_gallery_folder(target_real)||!is_dir(target_real)) {
		const char* msg="{\"error\":\"Invalid directory\"}";
		send_header(c, 400, "Bad Request", "application/json; charset=utf-8",
			(long)strlen(msg), NULL, 0, keep_alive);
		send(c, msg, (int)strlen(msg), 0);
		return;
	}
	char** names=NULL;
	size_t n=0, alloc=0;
	diriter it;
	if(dir_open(&it, target_real)) {
		const char* name;
		while((name=dir_next(&it))) {
			if(!strcmp(name, ".")||!strcmp(name, "..")) continue;
			char full[PATH_MAX];
			path_join(full, target_real, name);
			if(is_dir(full)&&!has_nogallery(full)&&has_media_rec(full)) {
				if(n==alloc) {
					alloc=alloc ? alloc*2 : 16;
					names=realloc(names, alloc*sizeof(char*));
				}
				names[n++]=strdup(name);
			}
		}
		dir_close(&it);
	}
	qsort(names, n, sizeof(char*), ci_cmp);
	size_t cap=4096, len=0;
	char* out=malloc(cap);
	out[0]='\0';
	sb_append(&out, &cap, &len, "{\"content\":[");
	for(size_t i=0; i<n; i++) {
		if(i) sb_append(&out, &cap, &len, ",");
		sb_append(&out, &cap, &len, "{\"name\":\"");
		sb_append_esc(&out, &cap, &len, names[i]);
		sb_append(&out, &cap, &len, "\",\"path\":\"");
		char tmp[PATH_MAX];
		path_join(tmp, target_real, names[i]);
		char tr[PATH_MAX], br[PATH_MAX];
		real_path(tmp, tr);
		real_path(BASE_DIR, br);
		const char* r=tr+strlen(br)+((tr[strlen(br)]==DIR_SEP) ? 1 : 0);
		char relurl[PATH_MAX];
		size_t j=0;
		for(size_t k=0; r[k]&&j<PATH_MAX-1; k++) {
			char ch=r[k];
			if(ch=='\\') ch='/';
			relurl[j++]=ch;
		}
		relurl[j]='\0';
		sb_append_esc(&out, &cap, &len, relurl);
		sb_append(&out, &cap, &len, "\"}");
		SAFE_FREE(names[i]);
	}
	SAFE_FREE(names);
	sb_append(&out, &cap, &len, "],");
	sb_append(&out, &cap, &len, "\"currentDir\":\"");
	sb_append_esc(&out, &cap, &len, dirparam);
	sb_append(&out, &cap, &len, "\",\"isRoot\":");
	sb_append(&out, &cap, &len, IS_EMPTY_STR(dirparam) ? "true" : "false");
	sb_append(&out, &cap, &len, "}");
	send_header(c, 200, "OK", "application/json; charset=utf-8", (long)len, NULL, 0, keep_alive);
	send(c, out, (int)len, 0);
	SAFE_FREE(out);
}

void handle_api_media(int c, char* qs, bool keep_alive) {
	char dirparam[PATH_MAX]={ 0 };
	int page=1;
	if(qs) {
		char* v=query_get(qs, "dir");
		if(v) {
			size_t max_len=sizeof(dirparam)-1;
			strncpy(dirparam, v, max_len);
			dirparam[max_len]='\0';
			SAFE_FREE(v);
		}
		char* p=query_get(qs, "page");
		if(p) {
			int t=atoi(p);
			if(t>0) page=t;
			SAFE_FREE(p);
		}
	}
	char target[PATH_MAX];
	if (dirparam[0]) {
		snprintf(target, sizeof(target), "%s/%s", BASE_DIR, dirparam);
	} else {
		snprintf(target, sizeof(target), "%s", BASE_DIR);
	}
	normalize_path(target);
	char base_real[PATH_MAX], target_real[PATH_MAX];
	if(!real_path(BASE_DIR, base_real)||!real_path(target, target_real)||
		!safe_under(base_real, target_real)||!is_dir(target_real)) {
		const char* msg="{\"error\":\"Invalid directory\"}";
		send_header(c, 400, "Bad Request", "application/json; charset=utf-8",
			(long)strlen(msg), NULL, 0, keep_alive);
		send(c, msg, (int)strlen(msg), 0);
		return;
	}
	if(!is_gallery_folder(target_real)||!is_dir(target_real)) {
		const char* msg="{\"error\":\"Invalid directory\"}";
		send_header(c, 400, "Bad Request", "application/json; charset=utf-8",
			(long)strlen(msg), NULL, 0, keep_alive);
		send(c, msg, (int)strlen(msg), 0);
		return;
	}
	char** files=NULL;
	size_t n=0, alloc=0;
	diriter it;
	if(dir_open(&it, target_real)) {
		const char* name;
		while((name=dir_next(&it))) {
			if(!strcmp(name, ".")||!strcmp(name, "..")) continue;
			if(has_ext(name, IMAGE_EXTS)||has_ext(name, VIDEO_EXTS)) {
				if(n==alloc) {
					alloc=alloc ? alloc*2 : 64;
					files=realloc(files, alloc*sizeof(char*));
				}
				files[n++]=strdup(name);
			}
		}
		dir_close(&it);
	}
	qsort(files, n, sizeof(char*), ci_cmp);
	int total=(int)n;
	int totalPages=(total+ITEMS_PER_PAGE-1)/ITEMS_PER_PAGE;
	if(totalPages==0) totalPages=1;
	if(page<1) page=1;
	if(page>totalPages) page=totalPages;
	int start=(page-1)*ITEMS_PER_PAGE;
	if(start>total) start=total;
	int end=MIN(start+ITEMS_PER_PAGE, total);
	size_t cap=4096, len=0;
	char* out=malloc(cap);
	out[0]='\0';
	sb_append(&out, &cap, &len, "{\"items\":[");
	for(int i=start; i<end; i++) {
		if(i>start) sb_append(&out, &cap, &len, ",");
		const char* filename=files[i];
		char full[PATH_MAX];
		path_join(full, target_real, filename);
		char tr[PATH_MAX], br[PATH_MAX];
		real_path(full, tr);
		real_path(BASE_DIR, br);
		const char* r=tr+strlen(br)+((tr[strlen(br)]==DIR_SEP) ? 1 : 0);
		char relurl[PATH_MAX];
		size_t j=0;
		for(size_t k=0; r[k]&&j<PATH_MAX-1; k++) {
			char ch=r[k];
			if(ch=='\\') ch='/';
			relurl[j++]=ch;
		}
		relurl[j]='\0';
		const char* type=has_ext(filename, IMAGE_EXTS) ? "image" : "video";
		sb_append(&out, &cap, &len, "{\"path\":\"");
		sb_append_esc(&out, &cap, &len, relurl);
		sb_append(&out, &cap, &len, "\",\"filename\":\"");
		sb_append_esc(&out, &cap, &len, filename);
		sb_append(&out, &cap, &len, "\",\"type\":\"");
		sb_append(&out, &cap, &len, type);
		sb_append(&out, &cap, &len, "\"}");
	}
	for(size_t i=0; i<n; i++) SAFE_FREE(files[i]);
	SAFE_FREE(files);
	sb_append(&out, &cap, &len, "],");
	char tmp[512]; 
	int nlen=snprintf(tmp, sizeof(tmp),
		"\"total\":%d,\"page\":%d,\"totalPages\":%d,\"hasMore\":%s}",
		total, page, totalPages, (page<totalPages) ? "true" : "false");

	if(nlen>=(int)sizeof(tmp)) tmp[sizeof(tmp)-1]='\0'; // safety
	sb_append(&out, &cap, &len, tmp);
	send_header(c, 200, "OK", "application/json; charset=utf-8", (long)len, NULL, 0, keep_alive);
	send(c, out, (int)len, 0);
	SAFE_FREE(out);
}

void handle_single_request(int c, char* headers, char* body, size_t headers_len, size_t body_len, bool keep_alive) {
	(void)headers_len; 
	char method[8]={ 0 }, url[PATH_MAX]={ 0 };
	if(sscanf(headers, "%7s %4095s", method, url)!=2) {
		send_text(c, 400, "Bad Request", "Malformed request", false);
		return;
	}
	char* qs=strchr(url, '?');
	if(qs) {
		*qs='\0'; qs++;
	}
	url_decode(url);
	char* range_header_value=get_header_value(headers, "Range:");
	if(strcmp(method, "POST")==0) {
		if(strcmp(url, "/api/folders/add")==0) {
			if(!body||body_len==0) {
				send_text(c, 400, "Bad Request", "Empty POST body", false);
				return;
			}
			char* body_copy=malloc(body_len+1);
			memcpy(body_copy, body, body_len);
			body_copy[body_len]='\0';
			handle_api_add_folder(c, body_copy, false);
			free(body_copy);
			return;
		}
		send_text(c, 405, "Method Not Allowed", "POST not supported for this endpoint", false);
		return;
	}
	if(strcmp(method, "GET")!=0) {
		send_text(c, 405, "Method Not Allowed", "Only GET and POST supported", false);
		return;
	}
	if(strcmp(url, "/")==0) {
		char p[1024];
		snprintf(p, sizeof(p), "%s/index.html", VIEWS_DIR);
		if(is_file(p)) send_file_stream(c, p, NULL, keep_alive);
		else send_text(c, 404, "Not Found", "index.html not found", keep_alive);
		return;
	}
	if(strcmp(url, "/api/folders")==0) {
		handle_api_folders(c, qs, keep_alive);return;
	}
	if(strcmp(url, "/api/tree")==0) {
		handle_api_tree(c, keep_alive);return;
	}
	if(strcmp(url, "/api/media")==0) {
		handle_api_media(c, qs, keep_alive);return;
	}
	if(strcmp(url, "/api/folders/list")==0) {
		handle_api_list_folders(c, keep_alive);return;
	}
	if(strncmp(url, "/images/", 8)==0) {
		char rel[1024];
		snprintf(rel, sizeof(rel), "%s/%s", BASE_DIR, url+8);
		normalize_path(rel);
		char base_real[1024], target_real[1024];
		if(real_path(BASE_DIR, base_real)&&real_path(rel, target_real)&&safe_under(base_real, target_real)&&is_file(target_real))
			send_file_stream(c, target_real, range_header_value, keep_alive);
		else send_text(c, 404, "Not Found", "Not found", keep_alive);
		return;
	}
	if(strncmp(url, "/js/", 4)==0) {
		char rel[1024];
		snprintf(rel, sizeof(rel), "%s/%s", JS_DIR, url+4);
		normalize_path(rel);
		char base_real[1024], target_real[1024];
		if(real_path(JS_DIR, base_real)&&real_path(rel, target_real)&&safe_under(base_real, target_real)&&is_file(target_real))
			send_file_stream(c, target_real, NULL, keep_alive);
		else send_text(c, 404, "Not Found", "Not found", keep_alive);
		return;
	}
	if(strcmp(url, "/bundled")==0) {
		if(is_file(BUNDLED_FILE)) send_file_stream(c, BUNDLED_FILE, NULL, keep_alive);
		else send_text(c, 404, "Not Found", "Not found", keep_alive);
		return;
	}
	if(strncmp(url, "/css/", 5)==0) {
		char rel[1024];
		snprintf(rel, sizeof(rel), "%s/%s", CSS_DIR, url+5);
		normalize_path(rel);
		char base_real[1024], target_real[1024];
		if(real_path(CSS_DIR, base_real)&&real_path(rel, target_real)&&safe_under(base_real, target_real)&&is_file(target_real))
			send_file_stream(c, target_real, NULL, keep_alive);
		else send_text(c, 404, "Not Found", "Not found", keep_alive);
		return;
	}
	send_text(c, 404, "Not Found", "Not found", keep_alive);
}

void handle_api_add_folder(int c, const char* request_body, bool keep_alive) {
	LOG_INFO("Add folder request: %s", request_body);
	const char* path_start=request_body;
	char path[PATH_MAX]={ 0 };
	bool found_path=false;
	while(*path_start&&!found_path) {
		path_start=strstr(path_start, "\"path\"");
		if(!path_start) break;
		path_start+=6;
		while(*path_start&&(isspace(*path_start)||*path_start==':')) {
			path_start++;
		}
		if(*path_start=='"') {
			path_start++;
			char* path_end=strchr(path_start, '"');
			if(path_end) {
				size_t path_len=path_end-path_start;
				strncpy(path, path_start, path_len);
				path[path_len]='\0';
				found_path=true;
			}
		}
	}
	if(!found_path||strlen(path)==0) {
		send_text(c, 400, "Bad Request", "Missing or invalid path field", keep_alive);
		return;
	}
	url_decode(path);
	if(!is_dir(path)) {
		send_text(c, 400, "Bad Request", "Path is not a valid directory", keep_alive);
		return;
	}

	if(is_gallery_folder(path)) {
		send_text(c, 400, "Bad Request", "Folder already in gallery", keep_alive);
		return;
	}

	add_gallery_folder(path);
	char response[512];
	snprintf(response, sizeof(response),
		"{\"status\":\"success\",\"message\":\"Folder added: %s\"}", path);
	send_header(c, 200, "OK", "application/json; charset=utf-8",
		(long)strlen(response), NULL, 0, keep_alive);
	send(c, response, (int)strlen(response), 0);
}

void handle_api_list_folders(int c, bool keep_alive) {
	size_t count;
	char** folders=get_gallery_folders(&count);

	size_t cap=4096;
	size_t len=0;
	char* out=malloc(cap);
	out[0]='\0';

	sb_append(&out, &cap, &len, "{\"folders\":[");

	for(size_t i=0; i<count; i++) {
		if(i>0) sb_append(&out, &cap, &len, ",");
		sb_append(&out, &cap, &len, "{\"path\":\"");
		sb_append_esc(&out, &cap, &len, folders[i]);
		sb_append(&out, &cap, &len, "\"}");
	}

	sb_append(&out, &cap, &len, "]}");

	send_header(c, 200, "OK", "application/json; charset=utf-8",
		(long)len, NULL, 0, keep_alive);
	send(c, out, (int)len, 0);
	SAFE_FREE(out);
}